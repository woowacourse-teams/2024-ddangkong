name: FE Review Reminder for Discord

on:
  pull_request:
    branches:
      - develop
  schedule:
    - cron: '0 2 * * 1-5' # 매주 월요일부터 금요일까지, 한국 시간 오전 11시에 실행
  workflow_dispatch:

jobs:
  review-reminder:
    runs-on: ubuntu-latest

    steps:
      - name: Send Reminder to Discord
        uses: actions/github-script@v7
        env:
          DISCORD_WEBHOOK: ${{ secrets.FE_REVIEW_NOTIFICATION_WEBHOOK_URL }}
          DISCORD_MENTION: ${{ secrets.FE_GITHUB_DISCORD_ID }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // GitHub 사용자명과 디스코드 아이디 또는 닉네임으로 매핑
            const discordMentions = JSON.parse(process.env.DISCORD_MENTION);

            const discordNotMentions = {
              'useon': '썬데이',
              'novice0840': '포메',
              'rbgksqkr': '마루',
            };

            async function getReviews(owner, repo, prNumber) {
              // 특정 PR의 리뷰 상태 가져오기
              const reviews = await github.rest.pulls.listReviews({
                owner,
                repo,
                pull_number: prNumber,
              });
              return reviews.data;
            }

            try {
              // 열려 있는 PR 목록 가져오기
              const pullRequests = await github.rest.pulls.list({
                owner,
                repo,
                state: 'open',
              });

              // FE 라벨이 달린 PR을 D-DAY가 임박한 순서로 정렬
              const fePrs = pullRequests.data
                .filter(pr => pr.labels.some(label => label.name.includes('FE')))
                .map(pr => {
                  const dLabel = pr.labels.find(label => label.name.startsWith('D-'));
                  const urgency = dLabel ? parseInt(dLabel.name.split('-')[1], 10) : Number.MAX_SAFE_INTEGER;
                  return {
                    ...pr,
                    urgency,
                    dLabelName: dLabel?.name || 'D-unknown',
                    updatedAt: pr.updated_at,
                    createdAt: pr.created_at,
                  };
                })
                .sort((a, b) => a.urgency - b.urgency);

              // 열린 PR 중 FE PR이 없는 경우 실행 종료
              if (fePrs.length === 0) {
                console.log('No FE PRs to remind.');
                return;
              }

              const messages = await Promise.all(
                fePrs.map(async pr => {
                  const reviews = await getReviews(owner, repo, pr.number);
                  const requestedReviewers = pr.requested_reviewers.map(r => r.login);

                  // 승인된 리뷰어 목록 확인
                  const approvedReviewers = reviews.filter(review => review.state === 'APPROVED').map(r => r.user.login);
                  const allApproved = requestedReviewers.every(reviewer => approvedReviewers.includes(reviewer));

                  // 각 리뷰어의 상태 생성
                  const reviewStatuses = reviews.map(review => {                    
                    // state마다 약자 정의
                    const stateAbbreviations = {
                      APPROVED: 'A',      
                      CHANGES_REQUESTED: 'RC', 
                      COMMENTED: 'C',
                    };

                    // 약자가 없는 상태일 경우 기본적으로 state 그대로 사용
                    const reviewState = stateAbbreviations[review.state] || review.state.toLowerCase();

                    return review.state === 'APPROVED'
                      ? `${discordNotMentions[review.user.login]}(${reviewState})` // APPROVED인 경우 멘션 없이 이름만 표시
                      : `<@${discordMentions[review.user.login]}>(${reviewState})`; // 나머지 상태인 경우 멘션
                  });

                  // 리뷰를 시작하지 않은 리뷰어 멘션
                  const notStartedReviewers = requestedReviewers.filter(
                    reviewer => !reviews.some(review => review.user.login === reviewer)
                  );

                  const notStartedMentions = notStartedReviewers.map(reviewer => {
                    return `<@${discordMentions[reviewer]}>(X)`;
                  });

                  const reviewStatusMessage = [...reviewStatuses, ...notStartedMentions];

                  // 생성일과 마지막 수정일 표시
                  const createdDate = new Date(pr.createdAt).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
                  const lastUpdated = new Date(pr.updatedAt).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });

                  // 모든 리뷰어가 APPROVED인 경우
                  if (allApproved) {
                    const authorMention = discordMentions[pr.user.login] || `${pr.user.login}`;
                    return `[[${pr.dLabelName}] ${pr.title}](${pr.html_url})\n리뷰어: ${reviewStatusMessage.join(', ')}\n<@${authorMention}>, 모든 리뷰어의 승인 완료! 코멘트를 확인 후 머지해 주세요 🚀`;
                  }

                  // 일반적인 리마인드 메시지
                  return `[[${pr.dLabelName}] ${pr.title}](${pr.html_url})\n리뷰어: ${reviewStatusMessage.join(', ')}`;
                })
              );

              // 최종 메시지 Discord에 전송
              const response = await fetch(process.env.DISCORD_WEBHOOK, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  content: `🍀 [FE] 리뷰가 필요한 PR 목록 🍀\n\n${messages.join('\n\n')}`,
                  allowed_mentions: {
                    parse: ["users"],
                  },
                }),
              });

              console.log('Response status:', response.status);
            } catch (error) {
              console.error('Error processing FE PR reminders:', error.message);
              throw error; // 워크플로우 실패 상태 반환
            }
