name: FE Review Reminder for Discord

on:
  schedule:
    - cron: '0 2 * * 1-5' # ë§¤ì£¼ ì›”ìš”ì¼ë¶€í„° ê¸ˆìš”ì¼ê¹Œì§€, í•œêµ­ ì‹œê°„ ì˜¤ì „ 11ì‹œì— ì‹¤í–‰
jobs:
  review-reminder:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Send Reminder to Discord
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          DISCORD_WEBHOOK: ${{ secrets.FE_REVIEW_NOTIFICATION_WEBHOOK_URL }}
        run: |
          const discordMentions = {
            'useon': 'ì¬ë°ì´',
            'novice0840': 'í¬ë©”',
            'rbgksqkr': 'ë§ˆë£¨',
          };

          const owner = '${{ github.repository_owner }}';
          const repo = '${{ github.event.repository.name }}';
          const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
          const DISCORD_WEBHOOK = process.env.DISCORD_WEBHOOK;

          async function main() {
            // ì—´ë¦° PR ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
            const pullRequests = await fetch(
              `https://api.github.com/repos/${owner}/${repo}/pulls`,
              {
                headers: {
                  Authorization: `token ${GITHUB_TOKEN}`,
                  Accept: 'application/vnd.github.v3+json',
                },
              }
            ).then(res => res.json());

            // FE ë¼ë²¨ì´ ë‹¬ë¦° PRì„ D-DAYê°€ ìž„ë°•í•œ ìˆœì„œë¡œ ì •ë ¬
            const fePrs = pullRequests
              .filter(pr => pr.labels.some(label => label.name === 'ðŸ«§ FE'))
              .map(pr => {
                const dLabel = pr.labels.find(label => label.name.startsWith('D-'));
                const urgency = dLabel ? parseInt(dLabel.name.split('-')[1], 10) : Number.MAX_SAFE_INTEGER;
                return { 
                  ...pr, 
                  urgency, 
                  dLabelName: dLabel?.name || 'D-unknown',
                  updatedAt: pr.updated_at, // ë§ˆì§€ë§‰ ìˆ˜ì • ì‹œê°„ ì¶”ê°€
                  createdAt: pr.created_at, // ìƒì„± ì‹œê°„ ì¶”ê°€
                };
              })
              .sort((a, b) => a.urgency - b.urgency);

            // ì—´ë¦° PR ì¤‘ FE PRì´ ì—†ëŠ” ê²½ìš° ì‹¤í–‰ ì¢…ë£Œ
            if (fePrs.length === 0) {
              console.log('No FE PRs to remind.');
              return;
            }

            const messages = await Promise.all(
              fePrs.map(async pr => {
                const reviews = await getReviews(owner, repo, pr.number);
                const requestedReviewers = pr.requested_reviewers.map(r => r.login);

                // ìŠ¹ì¸í•œ ë¦¬ë·°ì–´ ëª©ë¡ í™•ì¸
                const approvedReviewers = reviews.filter(review => review.state === 'APPROVED').map(r => r.user.login);
                const allApproved = requestedReviewers.every(reviewer => approvedReviewers.includes(reviewer));

                // ê° ë¦¬ë·°ì–´ì˜ ìƒíƒœ ìƒì„±
                const reviewStatuses = reviews.map(review => {
                  const discordUsername = discordMentions[review.user.login] || `@${review.user.login}`;
                  const reviewState = review.state.toLowerCase();
                  return review.state === 'APPROVED'
                    ? `${discordUsername.replace('@', '')}(${reviewState})` // APPROVEDì¸ ê²½ìš° ë©˜ì…˜ ì—†ì´ ì´ë¦„ë§Œ í‘œì‹œ
                    : `${discordUsername}(${reviewState})`; // ë‚˜ë¨¸ì§€ ìƒíƒœì¸ ê²½ìš° ë©˜ì…˜
                });

                // ì•„ì§ ë¦¬ë·°ë¥¼ ì‹œìž‘í•˜ì§€ ì•Šì€ ë¦¬ë·°ì–´ í‘œì‹œ
                const notStartedReviewers = requestedReviewers.filter(
                  reviewer => !reviews.some(review => review.user.login === reviewer)
                );

                const notStartedMentions = notStartedReviewers.map(reviewer => {
                  const discordUsername = discordMentions[reviewer] || `@${reviewer}`;
                  return `${discordUsername}(not started)`;
                });

                const reviewStatusMessage = [...reviewStatuses, ...notStartedMentions];

                // ìƒì„±ì¼ê³¼ ë§ˆì§€ë§‰ ìˆ˜ì •ì¼ í‘œì‹œ
                const createdDate = new Date(pr.createdAt).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });
                const lastUpdated = new Date(pr.updatedAt).toLocaleString('ko-KR', { timeZone: 'Asia/Seoul' });

                // ëª¨ë“  ë¦¬ë·°ì–´ê°€ APPROVEDì¸ ê²½ìš° ë©”ì‹œì§€ ìƒì„±
                if (allApproved) {
                  const authorMention = discordMentions[pr.user.login] || `@${pr.user.login}`;
                  return `ë§ˆê°ì¼: [${pr.dLabelName}]\nì œëª©: ${pr.title}\ní˜„í™©: ${reviewStatusMessage.join(', ')}\nìƒì„±ì¼: ${createdDate}\në§ˆì§€ë§‰ ìˆ˜ì •: ${lastUpdated}\n${authorMention}, ëª¨ë“  ë¦¬ë·°ì–´ì˜ ìŠ¹ì¸ ì™„ë£Œ! ì½”ë©˜íŠ¸ë¥¼ í™•ì¸ í›„ ë¨¸ì§€í•´ ì£¼ì„¸ìš” ðŸš€\në§í¬: ${pr.html_url}`;
                }

                // ì¼ë°˜ì ì¸ ë¦¬ë§ˆì¸ë“œ ë©”ì‹œì§€ ìƒì„±
                return `ë§ˆê°ì¼: [${pr.dLabelName}]\nì œëª©: ${pr.title}\ní˜„í™©: ${reviewStatusMessage.join(', ')}\nìƒì„±ì¼: ${createdDate}\në§ˆì§€ë§‰ ìˆ˜ì •: ${lastUpdated}\në§í¬: ${pr.html_url}`;
              })
            );

            // ìµœì¢… ë©”ì‹œì§€ Discordì— ì „ì†¡
            const finalMessage = `ðŸ€ [FE] ë¦¬ë·°ê°€ í•„ìš”í•œ PR ëª©ë¡ ðŸ€\n\n${messages.join('\n\n')}`;

            await fetch(DISCORD_WEBHOOK, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ content: finalMessage }),
            });
          }

          // íŠ¹ì • PRì˜ ë¦¬ë·° ìƒíƒœ ê°€ì ¸ì˜¤ê¸°
          async function getReviews(owner, repo, prNumber) {
            return await fetch(
              `https://api.github.com/repos/${owner}/${repo}/pulls/${prNumber}/reviews`,
              {
                headers: {
                  Authorization: `token ${GITHUB_TOKEN}`,
                  Accept: 'application/vnd.github.v3+json',
                },
              }
            ).then(res => res.json());
          }

          // ë©”ì¸ í•¨ìˆ˜ ì‹¤í–‰ ë° ì—ëŸ¬ ì²˜ë¦¬
          main().catch(err => {
            console.error('Error:', err);
            process.exit(1);
          });
